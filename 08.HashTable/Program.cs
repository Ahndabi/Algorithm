namespace _08.HashTable
{
	internal class Program
	{
		// 해시 테이블 중요!!
		/******************************************************
		 * 해시테이블 (HashTable)
		 * 
		 * 키 값을 해시함수로 해싱하여 해시테이블의 특정 위치로 직접 엑세스하도록 만든 방식
		 * 해시 : 임의의 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑
		 ******************************************************/

		// <해시테이블의 시간복잡도>
		// 접근			탐색		삽입		삭제
		// X			O(1)		O(1)		O(1)
		// 접근하려는 자료구조가 아님. 그래서 접근은 X

		// 트리는 어쨋든 내가 찾으려는 데이터를 찾을 때 이진탐색으로 해도 하나하나 그 데이터가 맞는지 
		// 찾아가야 하니까 어느정도 좀 시간이 걸린달까,,,

		// 몬스터를 죽였는데 그 몬스터는 포션을 떨어뜨린대. 그럼 Item이라는 데이터 저장소에서 포션이라는 아이템을 찾아야하지.
		// 몇번째 주소지를 가면 포션이 있을거야. 아이템 하나하나 뒤질 필요 없이 그 포션의 위치를 키값을 통해 위치를 저장하여 단박에 찾게 함.

		// 해싱이란?
		// 배열 기반으로 큰 영역을 미리 만들어놔. 그리고 키 값에 해당하는 숫자 혹은 문자, 열거형 등등을 해싱을 통해서
		// 숫자를 특정 인덱스로 만드는 것. 그럼 그 인덱스에 해당하는 위치를 단박에 찾아갈 수 있음
		// 내가 해시테이블을 만들 때 쓴 키값을 통해 찾으면 굉장히 빠른 속도로 데이터를 찾을 수 있음.

		// 데이터를 넣을 때 데이터를 판가름할 키값도 같이 넣는 거야. (ex. 아이템의 이름이라던가 숫자라던가)
		// 그럼 이 데이터를 해시테이블에 넣기 위해 해싱이라는 과정을 거침. 그 키값을 index로 바꿔주는 거임.
		// 키값을 인덱스로 바꾸는 과정을 해시라고 하고, 그걸 변환해주는 함수를 해시함수라고 한다.
		// 그럼 데이터를 가져오고 싶을 땐? 키 값을 인덱스화해서 해시함수를 적용하여 인덱스를 찾아 데이터를 가져온다.

		// 그래서 헤시테이블에는 띄엄띄엄 빈공간이 있을 수 있음. 차례대로 차곡차곡 넣는 방식이 아니기 때문.

		// 근데 해시의 조건이 있음.
		// <해시함수의 조건>
		// 1. 입력에 대한 해시함수의 결과가 항상 동일한 값이어야 한다.
		//    키 값을 줬을 때 헤시함수를 통해 나온 인덱스(주소)가 항상 동일한 녀석이어야 한다는 뜻.
		//    포션을 13으로 저장했는데 나중에 찾으려고 보니까 16으로 되어있다?? 안돼~!

		// <해시함수의 효율>
		// 1. 해시함수 자체가 느린경우 의미가 없음. (해시함수 구조가 막 미분을 하고 적분을 하고~!~! 이러면 의미X)
		// 2. 주소값 겹치면 효율성이 떨어질 수밖에 없음.. 그래서 해시함수의 결과가 밀집도가 낮아야 함.
		//    해시함수의 역할이 매우 중요한거야.(나이대로 키값X 핸드폰 뒷번호O 차라리 핸드폰 뒷자리가 낫지!)
		// 3. 해시테이블의 크기가 클수록 효율.

		// <해시테이블 주의점 - 충돌> **********중요***********
		// 해시함수가 서로 다른 입력 값에 대해 동일한 해시테이블 주소를 반환하는 것
		// 모든 입력 값에 대해 고유한 해시 값을 만드는 것은 불가능하며 충돌은 피할 수 없음
		// 대표적인 충돌 해결방안으로 체이닝과 개방주소법이 있음

		// <충돌해결방안 - 체이닝>
		// 해시 충돌이 발생하면 연결리스트로 데이터들을 연결하는 방식
		// 해시테이블에 여러개를 저장하는 대신, 그걸 링크드리스트를 통해 여러 노드로 저장하면 되는거야.
		// 그래서 다시 그 노드 안에서 찾음
		// C#에서는 체이닝 안 씀. 링크드리스트니까.. 개방주소법 씀
		// 장점 : 해시테이블에 자료가 많아지더라도 성능저하가 적음
		// 단점 : 해시테이블 외 추가적인 저장공간이 필요

		// <충돌해결방안 - 개방주소법>
		// 해시 충돌이 발생하면 다른 빈 공간에 데이터를 삽입하는 방식
		// 해시 충돌시 선형탐색, 제곱탐색, 이중해시 등을 통해 다른 빈 공간을 선정
		// 갑옷을 13에 저장했는데 포션도 13번지에 저장하려 했더니 이미 사용 중이네?
		// 그럼 그 다음 위치인 14번지에 포션을 저장하는 거임.(만약 14도 차 있으면 그 다음인 15에 저장)
		// 장점 : 추가적인 저장공간이 필요하지 않음, 삽입삭제시 오버헤드가 적음
		// 단점 : 해시테이블에 자료가 많아질수록 성능저하가 많음
		// 해시테이블의 공간 사용률이 높을 경우 성능저하가 발생하므로 재해싱 과정을 진행함
		// 재해싱 : 해시테이블의 크기를 늘리고 테이블 내의 모든 데이터를 다시 해싱 



		static void Dictionary()
		{
			// HashTable hashtable = new HashTable(); // 얘가 있긴 한데 얘 잘 안 씀
			Dictionary<string, Item> dictionary = new Dictionary<string, Item>();
					// 열거형으로 타입을 정렬해놔도 됨~!
			dictionary.Add("초기아이템", new Item("초보자용 검", 10));
			dictionary.Add("초기방어구", new Item("초보자용 가족갑옷", 30));
			dictionary.Add("전직아이템", new Item("푸른결정", 1));

			// 탐색
			Console.WriteLine(dictionary["초기아이템"].name); // 인덱서에 키값을 넣음.
															  // out : 초보자용 검
			// 접근
			dictionary.Remove("전직아이템");

			// 확인
			if(dictionary.ContainsKey("초기아이템"))    // 너 지금 초기아이템 있니?(키 값 찾는 함수)
				Console.WriteLine("딕셔너리에 초기아이템이 있음");
		}

		public class Item
		{
			public string name;
			public int weight;

			public Item(string name, int weight)
			{
				this.name = name;
				this.weight = weight;
			}
		}
		// 

		static void Main(string[] args)
		{
			Dictionary();
		}
	}
}