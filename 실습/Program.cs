using System.Drawing;
using System.Runtime.CompilerServices;

namespace 실습
{
	internal class Program
	{
		// 2. 해싱과 해시함수에 대한 조사(해시의 원리, 해싱함수의 효율 등)
		// 해시테이블은 키 값을 해시함수를 통해 index로 변환하여 그 위치에 저장할 수 있도록 한 자료구조이다.
		// 해싱이란, key값을 index로 변환하는 과정을 말한다.
		// 그 과정에서 key 값을 index로 변환해주는 함수를 해시함수라고 한다.
		// 해시테이블은 원하는 값을 찾을 때까지 하나하나 비교하면서 내려가는 트리형식의 자료구조와는 다르게
		// 각자 고유한 index 값을 통해 바로 그 위치에 접근이 가능하다.
		// 그래서 탐색, 삽입, 삭제의 시간복잡도는 모두 0(1)이다.

		// 해시테이블을 만들 때에는 배열 기반으로 큰 영역을 미리 힙영역에 만들어 놓는다. 
		// 해시테이블에 데이터를 넣을 때는 데이터를 판가름할 키값도 함께 입력하여 저장한다. 그 키값은 보통 int나 string을 많이 사용한다.
		// 그리고 키 값에 해당하는 숫자 혹은 문자나 열거형 등을 해싱을 통해서 키값을 특정 인덱스로 만드는 것이다.
		// 그러면 키값만 알면 그 인덱스에 해당하는 위치를 단박에 찾아갈 수 있어 굉장히 빠른 속도로 원하는 데이터를 찾을 수 있다.
		// 이러한 방식때문에 해시테이블에는 데이터가 차례대로 차곡차곡 넣어지지 않고 띄엄띄엄 저장이 된다.

		// 키값을 index로 변환해주는 함수인 해시함수는 조건을 가지고 있다.
		// 입력에 대한 해시함수의 결과는 언제나 동일한 값이어야 한다는 것이다.
		// 키값에 대해 처음 받았던 인덱스값이 나중에 데이터를 찾으려고 키값을 입력했을 때 다른 인덱스이면 안된다는 것이다.

		// 이러한 해시함수는 속도가 빠를 수밖에 없다. HashCode를 통해 키 값을 인덱스로 바꿔주면 되는데 이 과정이 복잡하고 느리게 된다면 그 의미가 없어진다.
		// 또한 키 값이 최대한 겹치면 안된다. 같은 주소값을 받게되면 해시테이블의 효율성이 떨어지게 된다. 시간복잡도가 0(1)이 아니게 되기 때문이다.
		// 그래서 키 값을 인덱서로 변환해주는 해시함수의 역할이 매우 중요하다.
		// 또한 그렇기에 해시테이블의 크기가 클수록 효율적이다. 주소값이 겹칠일이 그만큼 적어지기 때문이다.




		// 3. 해시테이블의 충돌과 충돌해결방안
		// 해시테이블에는 충돌에 대한 주의점이 있다.
		// 충돌이란, 해시함수가 서로 다른 키값에 대해 동일한 주소를 반환하는 것을 의미한다. 
		// 충분히 일어날 수 있는 일이며 모든 입력 값에 대해 고유한 해시 값을 만드는 것은 불가능하며 충돌은 피할 수 없다.
		// 충돌을 해결하기 위한 대표적인 방안으로는 체이닝과 개방주소법이 있다.

		// 체이닝이란, 해시 충돌이 발생했을 때 같은 인덱스에서 링크드리스트로 데이터들을 연결하는 방식이다.
		// 즉 같은 인덱스에 저장이 된다면 그 인덱스 안에서 노드들을 만들어 데이터들을 연결하는 것이다.
		// 체이닝의 장점은 해시테이블에 자료가 많아져도 성능 저하가 적는다는 것이고,
		// 단점은 해시테이블 외의 추가적인 저장공간이 필요하다는 것이다.
		// 또한 링크드리스트이기 때문에 C#에서는 체이닝 방식을 거의 사용하지 않고 개방주소법을 사용한다.

		// 개방주소법은 해시 충돌이 발생했을 때 다른 빈 주소값에 데이터를 삽입하는 방식이다.
		// 다른 주소값을 찾는 방법에는 선형탐색, 제곱탐색, 이중해시 등이 있다.
		// 개방주소법의 장점은 추가적인 저장공간이 필요하지 않고 삽입삭제 시 오버헤드가 적다.
		// 단점은 해시테이블에 자료가 많아질수록 성능저하가 증가한다는 것이다.
		// 해시테이블의 공간을 70~80%정도 사용했을 경우에는 재해싱 과정을 진행한다.
		// 재해싱이란 해시테이블의 크기를 늘리고 테이블 내의 모든 데이터를 다시 해싱하는 과정이다.

		static void Main(string[] args)
		{
			Dictionary<string, int> dictionary = new Dictionary<string, int>();
			Item item= new Item();
			dictionary.Add("아이템1", 10);
			dictionary.Add("아이템2", 20);
			dictionary.Add("아이템3", 30);

		
		}
		public class Item
		{
			public int weight;
			public Item()
			{
				this.weight = 0;
			}
		}
	}
}